---
title: "Monocle stuff"
author: "Trevor Manz"
date: "12/1/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(monocle3)
library(tidyverse)
library(patchwork)
source('./multi_component_RGE.R')
source('./learn_graph.R')
```

```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;

// Compute jaccard coefficient between nearest-neighbor sets
//
// Weights of both i->j and j->i are recorded if they have intersection. In this case
// w(i->j) should be equal to w(j->i). In some case i->j has weights while j<-i has no
// intersections, only w(i->j) is recorded. This is determinded in code `if(u>0)`.
// The original method described in the phenograph paper is used to calculate the weight.
//
// Author: Chen Hao, Date: 25/09/2015; updated by Xiaojie Qiu Nov. 12, 2017

NumericMatrix jaccard_coeff_cpp(NumericMatrix idx, bool weight) {
  int nrow = idx.nrow(), ncol = idx.ncol(), r = 0;
  NumericMatrix weights(nrow*ncol, 3);

  for(int i = 0; i < nrow; i ++) {
    for(int j = 0; j < ncol; j ++) {
      int k = idx(i,j) - 1;

      weights(r, 0) = i + 1;
      weights(r, 1) = k + 1;
      weights(r, 2) = 1;

      if(weight == TRUE) {

        NumericVector nodei = idx(i, _);
        NumericVector nodej = idx(k, _);

        int u = intersect(nodei, nodej).size();  // count intersection number
        int v = 2 * ncol - u;  // count union number

        if(u>0) {
          // weights(r, 0) = i + 1;
          // weights(r, 1) = k + 1;
          // weights(r, 2) = u / (2.0 * ncol - u) / 2;  // symmetrize the graph

          weights(r, 2) = (double) u / (double) v;  // normalize the values
        }
      }

      r ++;

    }
  }

  weights(_, 2) = weights(_, 2) / max(weights(_, 2));

  return weights;
}

// [[Rcpp::export]]
NumericMatrix jaccard_coeff(SEXP R_idx, SEXP R_weight) {
  NumericMatrix idx(R_idx);
  bool weight = as<bool>(R_weight);

  return jaccard_coeff_cpp(idx, weight);
}

NumericMatrix pnorm_over_mat_cpp(NumericMatrix num_links_ij, NumericMatrix var_null_num_links) {
  int n = num_links_ij.nrow();
  NumericMatrix tmp(n, n);

  for (int i = 0; i < n; i ++) {
    for (int j = 0; j < n; j ++) {
      // tmp(i, j) = Rcpp::pnorm( num_links_ij(i, j), 0.0, sqrt(var_null_num_links(i, j)), bool lower = false, bool log = false );
      tmp(i, j) = R::pnorm(num_links_ij(i, j), 0.0, sqrt(var_null_num_links(i, j)), 0, 0);
    }
  }
  return tmp;
}

// [[Rcpp::export]]
NumericMatrix pnorm_over_mat(SEXP R_num_links_ij, SEXP R_var_null_num_links) {
  NumericMatrix num_links_ij(R_num_links_ij);
  NumericMatrix var_null_num_links(R_var_null_num_links);

  return pnorm_over_mat_cpp(num_links_ij, var_null_num_links);
}


/***
edges$C = jaccard_dist
edges = subset(edges, C != 0)
edges$C = edges$C/max(edges$C)
*/
```

Load a dataset
```{r}
expression_matrix <- readRDS(url("http://staff.washington.edu/hpliner/data/packer_embryo_expression.rds"))
cell_metadata <- readRDS(url("http://staff.washington.edu/hpliner/data/packer_embryo_colData.rds"))
gene_annotation <- readRDS(url("http://staff.washington.edu/hpliner/data/packer_embryo_rowData.rds"))

cds <- new_cell_data_set(expression_matrix, cell_metadata = cell_metadata, gene_metadata = gene_annotation)
```

Preprocess
```{r}
cds <- preprocess_cds(cds, num_dim = 50)
cds <- align_cds(
  cds, 
  alignment_group = "batch", 
  residual_model_formula_str = "~ bg.300.loading + bg.400.loading + bg.500.1.loading + bg.500.2.loading + bg.r17.loading + bg.b01.loading + bg.b02.loading"
)
```

Dimensionality reduction with UMAP
```{r}
cds <- reduce_dimension(cds)
plot_cells(cds, label_groups_by_cluster=FALSE,  color_cells_by = "cell.type")
```

Cluster cells
```{r}
cds <- cluster_cells(cds)
plot_cells(cds, color_cells_by = "partition")
```

Exploring `learn_graph` function:

```{r}
p1 = bind_rows(
  as_tibble(t(X_subset)) %>% mutate(centroid = FALSE),
  as_tibble(t(blah)) %>% mutate(centroid = TRUE)
) %>% 
  ggplot(aes(V1, V2, color=centroid)) +
    geom_point()

p2 = bind_rows(
  as_tibble(t(X_subset)) %>% mutate(centroid = FALSE),
  as_tibble(t(medioids)) %>% mutate(centroid = TRUE)
) %>% 
  ggplot(aes(V1, V2, color=centroid)) +
    geom_point() 

(p1 + p2) + plot_layout(guides = 'collect') & theme_minimal()
```

```{r}
cds <- learn_graph_(cds, use_partition = FALSE, verbose=TRUE)
plot_cells(cds)
```

```{r}
# example with random data
t = seq(0, 2*pi, length.out=630)
mtest = rbind(
  sin(t),
  cos(t)
) * 10
plot(t(mtest))
```


```{r}
cds <- learn_graph_(cds, medioids = mtest, use_partition = FALSE, verbose=TRUE)
plot_cells(cds)
```


